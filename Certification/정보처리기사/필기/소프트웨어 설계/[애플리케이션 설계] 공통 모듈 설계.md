# [애플리케이션 설계] 공통 모듈 설계
> **목차**
> 1. [재사용](#1)
> 2. [공통 모듈](#2)
> 3. [설계 모델링](#3)
> 3. [소프트웨어 아키텍처](#4)

핵심 키워드는 `코드 라인` 을 통해 표기함

<br>

### 1. 재사용 <a id="1"></a>
> 시스템의 개발 시간 / 비용 절감을 위해 검증 기능을 파악하고 재구성해 시스템에 응용하기 위한 최적화 작업이다.
>   * 즉, 기존 소프트웨어 시스템 지식을 이용해 <u>새로운 소프트웨어를 구축하는 작업</u>이다.

<br>

**재사용의 유형**
* 함수와 객체 재사용 : Class / Function 단위 소스코드 재사용
* 컴포넌트 재사용 : 컴포넌트 (인터페이스 통신) 단위 재사용
* 애플리케이션 재사용 : 애플리케이션과 기능을 공유해 재사용

<br>

### 2. 공통 모듈 <a id="2"></a>
> **`모듈` : 크게 독립된 하나의 소프트웨어 / 하드웨어 단위**
> * 모듈화를 통해 분리된 시스템 기능을 의미
> * 서브 프로그램 및 루틴, 단위 프로그램, 작업 단위 등 의미로도 사용

<br>

**모듈의 특징**
* 독립성 : 각각의 모듈은 독립성을 가진다.
  * 모듈의 독립성은 `결합도` 와 `응집도`에 의해 결정된다.
* 다양한 조합 : 모듈 내부에는 모듈을 하나로 통합하는 수많은 조합이 존재
* 재사용 : 모듈은 단독으로 컴파일 가능, 재사용 가능
* 영향 최소화 : 독립성 높은 모듈일수록 수정 시 다른 모듈에 영향을 미치지 않음

<br>

**공통 모듈**
> 전체 프로그램 기능 중 특정 기능을 처리할 수 있는 실행 코드를 의미
> * 자체적으로 <u>컴파일이 가능함</u>
> * 여러 기능 및 프로그램에서 공통으로 사용하는 모듈을 의미
>   * ex) 날짜 처리 모듈 등

<br>

**공통 모듈의 원칙**
* `정`확성 : 기능이 시스템에 필요한지 아닌지 알 수 있게 정확히 작성
* `명`확성 : 일관되게 이해하고 <u>한가지로 해석할 수 있도록</u> 작성
* `완`전성 : 시스템이 구현될때 필요하고 요구되는 모든 것을 기술
* `일`관성 : 공통 기능 간에 <u>상호 충돌이 없도록</u> 작성
* `추`적성 : 기능의 요구사항 출처와 기능 간 유기적 관계에 대해 식별할 수 있도록 작성

<br>

**`모듈화`**
> 프로그램의 효율성을 위해 <u>시스템을 분해하고 추상화해 재사용 및 유지 관리를 쉽게 하는 기법</u>
> * <u>기능 단위의 모듈로 분해</u>하는 설계 및 구현 기법

<br>

**모듈화 기법**
* 루틴 : 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령의 모임
* 메인 루틴 : 프로그램의 주요한 부분으로, 전체의 개략적인 동작 절차를 표시하는 루틴
  * <u>메인 루틴은 서브 루틴을 호출</u>
* 서브 루틴 : 메인 루틴에 의해 호출되는 루틴

<br>

**모듈화 필요성**
* 모듈의 크기가 너무 작아 모듈 개수가 많아지면 통합 비용이 발생함
* 그렇다고 너무 크면 모듈당 개발 비용이 커짐
* <u>따라서, 모듈의 적당한 크기의 지점을 찾아야만 최소 비용으로 작업 가능</u>


<br>

**바람직한 모듈 설계 방안**
* 모듈의 독립성과 재사용성을 높이기 위해 `결합도는 낮추고 응집도는 높임`
* 모듈의 복잡도와 중복성을 줄이고 일관성을 유지
* 모듈의 기능은 예측이 가능해야 하며, 지나치게 제한적이면 안됌
* 적당한 모듈의 크기를 유지
* 모듈 간 효과적인 제어를 위해 <u>계층적 자료 조직</u>이 제시
* 유지보수가 용이해야하며, 이식성을 고려해야 함

<br>

**★ 모듈화 측정 지표**
* `응집도` : 모듈의 `내부` 요소들이 서로 관련 있는 정도
* `결합도` : 모듈 간에 `외부` 상호 의존도

<br>

**모듈화 유형**
* `★ 응집도(Cohesion)` : 모듈 하나의 독립성을 나타내는 개념, 내부 요소들의 상호 관련성
  * 유형 (`우 → 논 → 시 → 절 → 통(교) → 순 → 기` 순으로 높은 응집도)
    * `우`연적 응집도 : 서로 간에 <u>어떠한 관련성도 없는</u> 기능 요소의 수준
    * `논`리적 응집도 : <u>유사한 성격</u>을 갖거나 특정 형태로 분류되는 수준
    * `시`간적 응집도 : 연관된 기능이라보다는 <u>특정 시간</u>에 공통적으로 처리되는 수준
    * `절`차적 응집도 : 모듈이 <u>다수의 공통 관련 기능</u>을 가지는 수준
    * `통`신적 응집도(`교`환적 응집도) :  <u>동일한 입/출력</u>을 사용해 다른 기능을 수행하는 수준
    * `순`차적 응집도 : 모듈 내의 한 활동으로부터 <u>출력값을 이어받아</u> 다른 활동이 사용하는 수준
    * `기`능적 응집도 : 모듈 내부의 <u>모든 기능이 단일 목적을 위해</u> 수행되는 수준
  * `높은 응집도` : 단 하나의 기능만 모듈로 분리 가능 → (독립성 보장, 변경이 쉬움) = <u>유지보수 용이</u>
  * 낮은 응집도 : 하나의 모듈에 다양한 기능이 들어감 → 낮은 독립성 = <u>유지보수 불리</u>

<br>

* `★ 결합도(Coupling)` : 모듈과 모듈 (즉, 외부) 간의 연관성과 상호 의존성
  * 유형 (`내 → 공 → 외 → 제 → 스 → 자` 순으로 낮은 결합도)
  * `내`용 결합도 : 다른 모듈 내부의 변수나 기능을 다른 모듈에서 사용하는 수준
    *  하나의 모듈에서 다른 모듈 내용을 참조할 때 <u>내용적으로 결합되어 있는</u> 수준
  * `공`통 결합도 : 파라미터가 아닌 모듈 밖의 전역 변수를 참조하고 이를 갱신하는 수준
    * <u>공통 전역 변수나 데이터 영역</u>을 여러 모듈이 사용하는 경우
  * `외`부 결합도 : 두 개의 모듈이 외부의 통신 프로토콜, 인터페이스를 공유하는 수준
    * <u>외부 모듈</u>의 데이터 변수를 외부의 다른 모듈에서 참조하는 수준
  * `제`어 결합도 : 어떤 모듈이 다른 모듈의 내부 논리를 제어하기 위해 제어 신호를 이용하는 수준
    * 하위 모듈에서 상위 모듈로 <u>제어 신호</u>가 발생해 상위 모듈이 처리 명령을 수행하는 수준
  * `스`탬프 결합도 : 모듈 간 인터페이스로 배열, 객체, 구조 등이 전달되는 수준
    * 두 모듈이 `동일한 자료 구조`를 조회하는 수준 (다른 배열이라도 배열이라는 자료구조를 참조한다는 의미) 
  * `자`료 결합도 : 모듈 간 <u>파라미터</u>를 통해서만 모듈 간 상호 작용이 일어나는 수준
    * 완전한 함수형, 한 모듈의 내용을 변경하더라도 다른 모듈에는 영향을 미치지 않는 수준

<br>

**팬 인(Fan-In)과 팬 아웃(Fan-Out)**
> 팬 인과 팬 아웃을 활용해서 모듈의 계층 분석을 진행함
* `팬 인(Fan-In)` : 어떤 모듈을 제어하는 모듈의 수 (서브 모듈)
  * 모듈 자신을 기준으로 들어옴
* `팬 아웃(Fan-Out)` : 어떤 모듈에 의해 제어되는 모듈의 수 (내가 서브 모듈)
  * 모듈 자신을 기준으로 나감

<br>

* [참고] **팬 인과 팬 아웃의 예시**

![팬 인과 팬 아웃](https://jtrimind.github.io/assets/images/information-processing/2021-07-14-fan-in-fan-out.png)
  * A를 최상위 모듈로 가정할 시 F의 팬인과 팬아웃은 아래와 같음
  * 팬인 : B, C, D 모듈로 총 3개
  * 팬아웃 : G, H 모듈로 총 2개

<br>




### 3. 설계 모델링 <a id="3"></a>
> 요구사항 분석 단계에서 구체적인 구현 방법을 명시하는 기법

<br>

**설계 모델링 원칙**
* 변경에 용이하며, 구조화되어야 한다.
* 하나의 함수는 하나의 기능을 위한 자료만 사용하도록 규제한다. (단일 책임의 원칙)
* 독립적이고 기능적인 특성을 가지도록 분할 설계한다.
* 계층적인 구조를 가져야 한다.

<br>

**설계 모델링 유형**
* 구조 모델링
  * 소프트웨어 구성 컴포넌트의 유형, 인터페이스, 내부 설계 구조, 상호 연결 구조를 모델링
  * 시스템의 구성 요소와 이들의 관계를 모델링하며, `정적인 개념`임
  * 구성요소 : `프로시저`, 데이터 구조, 모듈, 파일 구조 등
    * `프로시저` : 프로그램을 기능에 따라 여러개 분해해 작성하는 것, 종류에는 서브 프로시저와 함수 프로시저가 있다.
* 행위 모델링 : 소프트웨어의 구성요소들이 언제 어떤 순서로 수행되는지 `동적인 개념`의 모델링
  * 구성요소 : 입 / 출력 데이터, 데이터 흐름 / 변환 / 저장 등

<br>

**소프트웨어 설계 유형**
* 자료구조 설계 : 소프트웨어에 필요한 자료 구조를 설계
* 아키텍처 설계 : 소프트웨어 시스템의 전체 구조를 기술하며, 구성 컴포넌트 간의 관계를 정의
* 인터페이스 설계 : 소프트웨어와 상호 작용하는 시스템과 사용자의 통신 방법을 정의
* 프로시저 설계 : 모듈이 수행할 기능을 절차적 기술로 바꾸는 설계
* 협약에 의한 설계 : 클래스에 대한 여러 가정을 공유하도록 명세한 설계
  * 소프트웨어 컴포넌트에 대한 인터페이스 명세를 선행·결과·불변 조건에 의해 분류하는 방법
  * 선행 조건 : 컴포넌트 오퍼레이션 사용 전에 참이 되어야 할 조건
  * 결과 조건 : 사용 후 만족되어야 할 조건
  * 불변조건 : 오퍼레이션이 실행되는 동안 항상 만족할 조건
> 자료구조, 아키텍처, 인터페이스, 프로시저, 협약에 의한 설계는 `상위 설계`에 속하며, 모듈 설계는 `하위 설계`에 속한다. <br>
> `상위 설계` : 시스템 수준에서 소프트웨어 컴포넌트 간의 관계를 정의하는 설계 <br>
> `하위 설계` : 컴포넌트 내부의 구성 요소와 동적 행위를 정의하는 설계

<br>

**★소프트웨어 설계 원리**
* 상향식 설계 : 하위 기능 → 상위 기능으로 설계를 접근해 가는 방식
  * 기존 컴포넌트들을 조합해 시스템을 개발하는 경우 적합
  * 상위 인터페이스가 정의되어 있어야 기능 추가와 설계에 유리함
* 하향식 설계 : 상위 기능 → 하위 기능으로 설계를 접근해 가는 방식
  * 시스템 명세가 정확한 경우와, 모든 것을 새로 개발하는 작업에 적합
  * 레벨이 낮은 데이터 구조의 세부 사항은 설계 초기 단계에서 필요함

<br>

**코드 설계**
> 데이터 분류나 조합을 쉽게 하기 위해 사물을 코드로 표현해 설계하는 기법

<br>

**코드의 기능**
* 표준화 : 정보를 일정한 기준에 따라 통일적으로 표현하는 기능
* 분류 : 정보들을 동일한 특성을 가진 데이터로 그룹화하는 기능
* 식별 : 다른 것들과 구별될 수 있는 기능
* 배열 : 일련의 순서로 나열할 수 있는 기능
* 간소화 : 정보의 표현을 간소화해서 나타낼 수 있는 기능
* 연상 : 정보를 표현하고자 하는 대상체 뜻과 의미가 코드에 내포되게 하는 기능
* 암호화 : 정보의 외부 표현을 감추고자 하는 기능
* 오류 검출 : 정보 입력이나 관리 시 잘못된 정보를 찾아내는 기능

<br>

**코드 설계 종류**
* 연상 코드 : 코드만 보고 대상을 연상할 수 있게끔 일정한 약어의 코드로 구성하는 것
  * `ex)` KR(KOREA), US(USA), FUNC(FUNCTION)
* 블록 코드 : 공통성이 있는 것을 블록으로 구분한 후 각 블록 내에서 일련번호를 부여하는 것
  * `ex)` 상품의 모델번호 등, LG-01321, SAMSUNG-01323
* 순차 코드 : 일정한 기준에 따라 순서대로 일련번호를 부여한 코드
  * `ex)` : 학교 학급의 키번호 등
* 표의 숫자 코드 : 대상 자료의 물리적 수치인 길이, 넓이, 용량 등을 표시한 코드
  * `ex)` : 168-58 (키-몸무게) 등
* 십진 코드 : 10진수 형태로 표현한 코드
  * `ex)` : 상품 코드(110234), 멤버쉽 카드(4023020) 등
* 그룹 분류식 코드 : 대상을 일정 기준에 따라 대분류/중분류/소분류로 구분
  * `ex)` : 학번 201603422의 경우 2016학년 입학, 03번의 과 코드, 422번 순번의 학생 등

<br>

**코드 오류 종류**
* 사본 오류(Transcription Error) : 한 자리를 잘못 표기한 경우
* 전위 오류(Transposition Error) : 연속된 두 글자가 서로 바뀌어 표기된 경우
* 생략 오류(Omission Error) : 한 글자를 누락한 경우
* 첨가 오류(Admission Error) : 한 글자를 더 첨가한 경우
* 이중 전위 오류(Double Transcription Error) : 전위 오류가 중복 발생한 경우

<br>

**HIPO(Hierarchy Input Process Output)**
> HIPO는 시스템 분석, 설계, 문서화 시 사용되는 `하향식 소프트웨어 개발 전용 문서화 도구`이다.

**HIPO의 특징**
* 체계적인 문서 관리
* 기호와 도표를 사용한 이해 용이성
* 기능과 자료의 의존 관계 표기 가능
* 변경 및 유지보수의 용이
* HIPO CHART를 사용하여 인터페이스를 계층적 구조로 표현하는 기능 지원
  * HIPO CHART의 종류
    * 가시적 도표 : 시스템의 전체 기능과 흐름을 보여주는 계층 구조도
    * 총체적 도표 : 입력, 처리, 출력에 대한 정보를 제공하는 도표, 프로그램 기능을 서술하는 도표
    * 세부적 도표 : 총체적 도표에 표시된 기능을 구성하는 기본 요소에 대해 상세히 기술하는 도표

<br>

### 4. 소프트웨어 아키텍처 <a id="4"></a>
> 소프트웨어 아키텍처는 여러가지 소프트웨어의 구성요소와 구성요소들의 관계를 표현하는 시스템 구조이다.
> * 소프트웨어를 설계하고 전개하기 위한 지침과 원칙이다.
> * 소프트웨어 아키텍처는 시스템의 `비기능적인 요소에 집중해서 만들어지지만, 기능적인 요소도 고려한다`.

<br>

**소프트웨어 아키텍처 4+1 뷰**
> 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적 접근 방법이다.
> * 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 이들 4개의 구조가 서로 충돌하지 않는지, <br>시스템 요구사항을 충족시키는지 증명하기 위한 체크 방법으로 유스케이스 뷰(+1)을 활용한다.

<br>

**4+1 뷰의 구성요소**
* `유스케이스 뷰` : 사용자, 설계자, 테스트 관점에서 외부 행위자에 대해 인식되는 시스템의 기능 요구사항을 보여주는 뷰
* `논리 뷰` : 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
* `프로세스 뷰` : 시스템의 비기능적인 속성으로 자원의 효율적인 사용을 보여주는 뷰
  * 비동기 실행, 병행  처리, 이벤트 처리 등이 이에 해당됌
* `구현 뷰` : 개발 환경 내에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
  * 컴포넌트 구조와 의존성을 보여주며, 컴포넌트에 관한 부가적 정보를 정의
* `배포 뷰` : 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는 가를 보여주는 뷰
  * 물리적 시스템을 구성하고 있는 각 부분들의 분산 및 설치 형태에 초점을 맞춤

<br>

**★소프트웨어 아키텍처 패턴**
* `계층화 패턴` : 시스템을 레이어(계층)으로 구분해 구성하는 패턴
  * 계층화 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호 작용이 이루어짐
  * 각 하위 모듈은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공한다.
* `클라이언트-서버` 패턴 : 하나의 서버와 다수의 클라이언트로 구성된 패턴
  * 사용자가 클라이언트를 통해 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스를 제공한다.
  * 서버는 클라이언트로부터 요청을 대기받음
* `파이프-필터 패턴` : 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 `단방향 패턴`
  * 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복한다.
* `브로커 패턴` : 분리된 컴포넌트들로부터 이루어진 분산 시스템에서 사용되며, 하나의 브로커가 컴포넌트들의 통신을 중개하는 패턴
* `모델-뷰-컨트롤러 패턴(MVC)` : 대화형 애플리케이션을 모델, 뷰, 컨트롤 뷰 3개의 서브 시스템으로 구조화하는 패턴
  * MVC 패턴의 구성 요소
    * `모델(M)` : 핵심 기능과 데이터를 보관
    * `뷰(V)` : 사용자에게 정보 표시(다수의 뷰가 정의될 수 있음)
    * `컨트롤러(C)` : 사용자에게 요청을 입력받아 처리
  * MVC 패턴은 각 부분이 별도의 컴포넌트로 분리되어 있어 별도 개발 작업 수행 및 코드의 효율적 재사용이 가능
* `마스터-슬레이브 패턴` : 연산, 통신, 조정 등을 책임지는 마스터와 이에 따른 동기화 대상인 슬레이브로 구성되는 패턴
  * 일반적으로 실시간 시스템에서 사용된다.

<br>

> 계층화 패턴과 파이프-필터 패턴의 차이
> 계층화 패턴은 하위, 상위 모듈의 개념으로서, 객체지향적인 관점에서 추상화와 일반화를 수행하는 인터페이스 개념과 동일하다. <br>
> 파이프-필터 패턴은 데이터적인 개념으로써, 하나의 입력 데이터가 시스템을 거쳐 변환/정제된 데이터가 다음 시스템에 전달되어 연속적으로 변환/정제되는 패턴을 의미한다.

<br>

**소프트웨어 아키텍처 품질 속성**
> 아키텍처 비용 평가를 위해 필요한 사항을 정의해 놓은 속성이다. <br>
> 아키텍처 품질 속성은 이해관계자들의 품질 요구사항을 반영하여 결정한다.
* 시스템 품질 속성 : 가용성, 변경 용이성, 성능, 사용 편의성, 시험 용이성 등
* 비즈니스 품질 속성 : 시장 적시성, 비용과 이익, 시스템 프로젝트 생명 주기, 목표 시장, 신규 발매 일정, 노후 시스템과 통합 등
* 아키텍처 품질 속성 : 개념적 무결성, 정확성과 안정성, 개발 용이성 등