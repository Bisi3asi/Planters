# [요구사항 확인] 현행 시스템 분석
> **목차**
> 0. 서론
> 1. 요구분석 기법
> 2. UML
> 3. 애자일
> 4. Reference

핵심 키워드는 `코드 라인` 을 통해 표기함
<br>

## 0. 서론
```agsl
본 파트는 평소에 친숙하게 다가왔던 
UML, ERD, 시퀸스 다이어그램과 같은 문서화 기법과 함께,
TDD, 애자일, Pair Programming과 같은 개발 방법론을 
정의하고 설명하는 파트입니다.

현 파트를 학습하며 저희가 평소 사용한 개발 요소가 
어느 범주에 포함되는지 확인하기 좋았습니다.

한번 참고하시면 좋을 것 같습니다! 😁
```

<br>

## 1. 요구분석
> * 사용자 요구를 추출해 목표를 설정하고, 어떤 방식으로 해결할 것인지 결정하는 단계
> * 사용자 요구사항의 모호함을 해소하는 단계

<br>

### [특징]
* 소프트웨어의 실질적 첫 단계로 사용자의 요구를 이해하는 단계
* 분석 결과 문서화를 통해 향후 유지보수 용이성 도모
* 구체적 명세를 위해 `소단위 명세서`가 활용될 수 있음
   *  `소단위 명세서` : 데이터 흐름도 처리를 소규모로 나눠 정리한 논리적 명세서
* 개발 비용이 많이 소모되지는 않음
* 도메인 분석을 통해 요구 정보를 수집, 배경 분석을 통해 `모델링`을 진행
* 요구사항 분석 시 요구사항 `확인`, `검증`, `비용 추정`이 가능하게 명확히 기술해야 함

<br>

### [요구사항 분석 단계 절차]
1. 요구사항 분류
   * 요구사항 유형(`기능적 요구사항` / `비기능적 요구사항`) 확인
       * `기능적 요구사항` : 기능과 관련해 소프트웨어가 가져야 할 요구사항
       * `비기능적 요구사항` : 성능, 보안, 품질 등 소프트웨어 비기능적 요구사항
   * 요구사항이 소프트웨어에 미치는 영향과 생명주기 변경상태를 확인
2. 개념 모델링 생성 및 분석
   * `모델링` : 요구사항을 더 쉽게 이해할 수 있도록 현실 세계의 상황을 단순화하는 모델을 만드는 것
       * `모델` : 객체 모델, 상태 모델, 데이터 모델 등 다양한 모델이 존재
       * `모델링` : DFED, UML 다이어그램, ERD 
3. 요구사항 할당 : 요구사항을 만족시키기 위한 아키텍처 구성요소를 식별하는 단계
   * 다른 구성 요소와 상호작용하는지 분석을 통해 추가적인 요구사항 식별 가능
4. 요구사항 협상 : 서로 상충되는 요구사항에서 적절한 합의를 도출하는 단계
5. 정형 분석 : 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현하는 단계
   * 구문과 의미를 갖는 정형화된 언어를 사용해 수학적 기호로 표현
   * 요구사항 분석의 마지막 단계에서 이루어짐

<br>

### [요구사항 분석 기술]
* 청취 기술
* 인터뷰와 질문 기술
* 분석 기술
* 중재 기술
* 관찰 기술
* 작성 기술
* 조직 기술
* 모델 작성 기술

<br>

### [요구사항 분석의 기능 모델링 기법]
> 데이터 흐름도(DFD), 자료 사전(DD)이 존재한다.

<br>

* `데이터 흐름도 (DFD)`
  * 각 프로세스에 따라 데이터가 흐르며 변환되는 모습을 도식화
  * 시스템 분석과 설계에 유용하게 사용되는 다이어그램이며, 가장 보편적으로 사용됌
  * `자료 흐름 그래프` 혹은 `버블 차트`라고도 함
  * 구조적 분석 기법에 이용된다.
  * 데이터 흐름에 중심을 두며, **제어의 흐름은 중요하지 않다.**
  * **시간 흐름을 명확하게 표현할 수는 없다.**

<br>

  * 구성 요소 / 표기 (하단 DFD 이미지 참고)

  ![DFD](http://itwiki.kr/images/1/10/%EC%9E%90%EB%A3%8C%ED%98%B8%EB%A6%84%EB%8F%84.png)
* `처리기 / 원(○)` : 입력 데이터를 정제하는 기능
* `데이터 흐름 / 화살표(→)` : 데이터 흐름을 나타내는 요소
* `데이터 저장소 / 평행선 (=)` : 데이터 저장소
* `단말 / 사각형 (□)` : 프로세스의 시작과 종료

<br>

* `자료 사전 (DD)`
  * 자료 요소의 집합, 흐름, 저장 의미, 관계 등을 명시하는 사전
  * 각 자료의 항목과 이름, 길이와 같은 데이터 참조를 위해 작성
  * 조직 내 팀원에게 특정 자료 용어가 무엇인지 전달하고 용어 정의를 취합하기 위해 사용
  * 자료 흐름도 자료 사전에 정의되어 있어야 함
  * **자료 사전 기호**
    * `=` : 자료 정의로서 ~로 구성되어 있음을 나타냄
    * `+` : 자료의 연결을 나타내는 기호
    * `()` : 자료 생략이 가능함을 나타냄
    * `{}` : 자료 반복을 나타냄 
      * 괄호 좌측에는 최소 반복, 우측에는 최대 반복을 기록 `ex) 1{abc}3`
      * 반복 횟수를 기록하지 않을 시 최소는 0, 최대는 무한대를 의미
    * `[]` : 자료 선택을 나타냄, | 기호로 선택 가능 항목을 표시 `ex) [foo|bar]`
    * `**` : 자료 설명을 나타내는 주석
  * **작성 원칙**
    * 자료의 의미 기술 : 중복 기술을 회피하며, 주석을 통해 기술
    * 구성항목의 기술 : 구성 항목을 그룹으로 묶으며, 그룹에 대한 의미있는 이름을 정의
    * 동의어 규정 준수 : 사용하는 용어를 이용해 자료를 정의하는 것을 지향
    * 자료 정의의 중복 제거 : 기존 용어의 중복을 제거해야 함

<br>

## 2. UML
> 소프트웨어 개발 과정에서 산출물 명세화, 시각화, 문서화 시 사용되는 모델링 기술과 방법론을 통합해 만든 표준화된 범용 모델링 언어

### [특징]
* 방법론을 통합한 언어로 표준화된 모델링 기법을 제공
* `가시화 언어` : 개념 모델 작성 시 오류가 적고 의사소통 용이
* `구축 언어` : 다양한 프로그래밍 언어로 실행 시스템 예측 가능, UML을 소스 코드로 변환 가능
* `명세화 언어` : 정확한 모델 제시, 완전한 모델 작성 가능
* `문서화 언어` : UML을 통한 시스템 평가 및 의사소통 문서 작성 가능

<br>

### [구성 요소]
* `사물` : 주제를 나타내는 요소, 명사 / 동사를 의미
* `관계` : 관계를 나타내는 요소, 형용사 / 부사를 의미
* `다이어그램` : 사물과 관계를 모아 그림으로 표현, 9가지 형태로 정의

<br>

### [UML 다이어그램 종류]
> UML 다이어그램은 구분에 따라 구조적(정적) 다이어그램과 행위적(동적) 다이어그램으로 나뉘어짐

<br>

정적 다이어그램
  * `[클]래스` : 클래스의 정적 구조, 클래스와 클래스 간 관계를 표현
    * 구성요소 : 클래스 이름, 속성, 연산, 접근 제어자
      * 속성 : 클래스 특징에 이름을 부여
      * 연산 : 클래스 객체의 메소드
      * 접근 제어자 : 클래스 내부 접근 정도 표현
        * `-` : private
        * `+` : public
        * `#` : protected
        * `~` : default
  * `[객]체` : 인스턴스 개념을 표현
  * `[컴]포넌트` : 코드 컴포넌트 기반 물리적 구조 표현
  * `[배]치` : 컴포넌트 사이 종속성을 표현
  * `[복]합체 구조` : 클래스나 컴포넌ㅌ 등 물리적 요소들의 위치를 표현
  * `[패]키지` : 유스케이스, 클래스 등 모델 요소를 그룹화한 관계를 표현

<br>

행위적 다이어그램
  * `[유]스케이스` : 사용자 관점의 시스템 활동 표현
    * 구성요소 : 유스케이스, 액터, 시스템
      * 유스케이스 : 시스템이 제공하는 서비스 및 액터의 일련 행위
      * 액터 : 사용자가 시스템에서 수행하는 역할
      * 시스템 : 전체 시스템의 영역 표현
    * 구성요소 간의 관계 : 연관, 포함, 확장, 일반화
      * 연관 : 유스케이스와 액터 간의 상호작용 표현 / 실선으로 표기
      * 포함 : 유스케이스가 유스케이스의 실행을 전제로 함 / 점선 화살표, `<<include>>` 로 표기
      * 확장 : 특정 조건에 따라 유스케이스가 유스케이스를 수행함 / 점선 화살표, `<<extend>>` 로 표기
      * 일반화 관계 : 유사한 유스케이스와 액터를 모아 그룹화 / 실선 화살표로 표기
  * `[시]퀀스` : 객체 간 상호작용 위주의 표현
    * 구성요소 : 객체, 생명선, 실행, 메시지, 회귀 메시지
      * 객체 : 다이어그램 내 상단에 표시되며 생명선을 가짐 / 사각형 안에 밑줄 친 이름으로 명시
      * 생명선 : 객체의 생명주기 동안 발생 이벤트 명시 / 객체로부터 뻗어가는 점선으로 표기
      * 실행 : 오퍼레이션이 실행되는 시간 / 선 내 직사각형으로 표기
      * 회귀 메시지 : 객체에 대한 함수를 호출 / 회귀하는 화살표
  * `[커]뮤니케이션` : 시퀸스 다이어그램과 같이 동작에 참여하는 객체의 메시지 표현
  * `[상]태` : 객체의 상태 변화 위주 표현
    * 구성요소 : 상태, 시작 상태, 종료 상태, 전이, 전이 조건, 이벤트
      * 상태 : 객체가 존재할 수 있는 조건 / 둥근 사각형 안 객체 상태 기술로 표기
      * 시작 상태 : 객체의 시작 상태 / 속이 채워진 원으로 표기
      * 종료 상태 : 객체의 종료 상태 / 두 겹의 원에 속이 채워진 원으로 표기
      * 전이 : 객체의 상태가 다른 상태로 변경 / 화살표로 표기
      * 전이 조건 : 특정 조건 만족 시 전이  / 화살표 상단 `[]` 전이 조건 표기
      * 이벤트 :  상태의 변화를 주는 현상 / 화살표 상단 이벤트 조건 표기
  * `[활]동` : 시스템이 어떤 기능을 수행하는지 처리 로직이나 처리의 흐름대로 순서 표현
  * `[타]이밍` : 객체 상태 변화와 시간 제약을 명시적으로 표현

<br>

### [UML 관계]
> 사물과 사물 사이 연관성을 표현한다.

관계 종류
* 연관 관계 : 2개 이상의 사물이 서로 관련된 상태
  * 표기 방법 : 영향을 주는 사물이 영향을 받는 사물에 대해 실선 화살표로 표기
      * 서로 영향을 주는 양방향일 경우 화살표 생략
* 의존 관계 : 서로 연관은 있으나 필요에 따라 짧은 시간동안만 연관을 유지하는 상태 
  * 표기 방법 : 영향을 주는 사물이 영향을 받는 사물에 대해 점선 화살표로 표기
* 일반화 관계 : 하나의 사물이 다른 사물을 상속하는 관계
  * 표기 방법 : 구체화된 자식 사물이 일반화된 부모 사물을 실선 빈 화살표로 가리켜 표기
* 실체화 관계 : 하나의 오퍼레이션이 인터페이스를 구현하는 관계
  * 표기 방법 : 구현한 오퍼레이션이 인터페이스 오퍼레이션을 점선 빈 화살표로 가리켜 표기
* 포함 관계 : 사물의 포함 관계로, 포함하는 사물의 변화가 포함되는 사물에 영향을 미치는 관계
  * ex ) Player (포함하는 쪽) / Mouse, Keyboard(포함되는 쪽) 
  * 표기 방법 : 포함되는 쪽은 실선 화살표, 포함하는 쪽은 속이 채워진 마름모로 연결해 표현
* 집합 관계 : 사물의 집합 관계
  * ex ) Person (포함하는 쪽) / Arm, Leg, Eye(포함되는 쪽)
  * 표기 방법 : 포함되는 쪽은 실선 화살표, 포함하는 쪽은 속이 빈 마름모로 연결

<br>

`[참고] UML 관계의 포함(합성) 관계와 집합(집약) 관계`
> 포함 관계는 사물에 미치는 영향의 관점이며, 집합 관계는 사물 간의 포함 관점이다. (워딩이 애매하다)

![UML 포함, 집합](https://gmlwjd9405.github.io/images/class-diagram/set-uml-example.png)

<br>

### [UML 확장 모델의 스테레오 타입]
> UML의 새로운 요소를 만들기 위한 확장 메커니즘이다. <br>
> * 형태는 UML 요소를 그대로 차용하지만 내부 의미가 다르게 확장된다.
> * 스테레오 타입은 <<>> 기호를 사용해 표현한다.

유형
* `<<include>>` : 유스케이스가 어떤 시점에 다른 유스케이스를 실행 / 포함함
* `<<extend>>` : 유스케이스가 어떤 시점에 조건부로 유스케이스를 실행
* `<<interface>>` : 모든 메서드가 추상 메서드나 상수로 구성되어 있는 클래스
* `<<entity>>` : 정보 또는 오래 지속되는 연관 행위를 형상화하는 클래스
  * 기억 장치에 저장되어야 할 정보를 나타냄
* `<<boundary>>` : 시스템과 외부 액터와의 상호작용을 담당
* `<<control>>` : 시스템이 제공하는 기능의 로직 및 제어를 담당

<br>

`[참고] UML 스테레오 타입 기호`

![UML 스테레오 타입](https://velog.velcdn.com/images%2Fcsy9604%2Fpost%2F2bf5a359-4bbe-4eac-9fbb-e0f224236e90%2Fimage.png)


## 3. 애자일
> 개발과 함께 즉시 피드백을 받아 유동적으로 개발하는 방법론

### [등장 배경]
> 기존 개발방법론의 한계를 극복하기 위해 등장
* 소프트웨어 개발 환경의 변화 : 모바일 환경으로 개발 트렌드가 변화, 시장 적시성과 잦은 배포 필요
* 기존 개발방법론의 환계 : 전통적 방법론은 문서 및 절차 위주로 변화에 대응 어려움

<br>

### [특징]
* 요구사항은 기능 중심으로 정의
* 절차와 도구보다 개인 소통을 중시
* 작업 계획을 짧게 세워 유연하고 신속한 대처
* 소프트웨어 실행에 가치 중점
* 고객과의 피드백을 중요하게 생각
* `해당 특징을 기반으로 한 애자일 선언문이 존재`

<br>

### [애자일 선언문]
* 공정과 도구보다 개인과 상호작용
* 계획을 따르기보다 변화에 대응하기
* 포괄적 문서보다 동작하는 소프트웨어
* 계약 협상보다 고객과의 협력

<br>

### [주요 애자일 유형]
`XP(eXtreme Programming)`
> 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이는 방법론
    
* 5가지 가치 : `용기`, `단순성`, `의사소통`, `피드백`, `존중`
* 12가지 기본 원리
  * Pair Programming (짝 프로그래밍)
  * 공동 코드 소유
  * CI (지속적 통합)
  * 계획 세우기 : 고객 요구 비즈니스 가치를 정의하고, 개발자가 필요한 것은 어떤 것인지 설명
  * 작은 릴리즈
  * 메타포어 : 공통적인 이름체계와 시스템 서술서를 바탕으로 함
  * 간단한 디자인
  * TDD (테스트 기반 개발)
  * 리팩토링 : 프로그램의 기능을 바꾸지 않으면서 중복제거, 단순화 실시
  * 40시간 작업 : 개발자가 피곤으로 인해 실수하지 않도록 40시간 이상 일주일에 일하면 안된다는 원리 🤔
  * 고객 상주 : 개발자들의 질문에 즉각 답해줄 수 있는 고객을 프로젝트에 풀타임 상주
  * 코드 표준 : 모든 코드에 대한 컨벤션을 지정

<br>

`Scrum`
> 매일 정해진 시간, 장소에서 모여서 짧은 시간의 개발을 하는 방법론

* 주요 용어
  * 제품 책임자 : 이해관계자의 의견을 종합해 제품에 대한 요구사항을 작성하는 주체
    * 의사결정자로써 제품에 대한 이해가 높아야 함 
    * 주로 개발 의뢰자나 사용자가 담당
  * 제품 백로그 : 제품과 프로젝트 관련 요구사항
    * 스크럼 팀이 해결해야 하는 목록 
    * 소프트웨어 요구사항 및 아키텍처 정의등이 포함
  * 스프린트 : 2 ~ 4주의 짧은 개발 기간 반복적 수행으로 개발품질 향상
  * 스크럼 미팅 : 매일 15분 정도 미팅으로 TO-DO List 수립
    * Daily 미팅으로도 통칭함
  * 스크럼 마스터 : 프로젝트와 스크럼의 리더
  * 스프린트 회고 : 스프린트 주기를 되돌아보며 개선점등을 확인하거나 기록
    * 스프린트 종료 후 혹은 일정 주기로 시행
  * 번 다운 차트 : 남아있는 백로그 대비 시간을 그래픽적으로 표현

<br>

`Lean`
* 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 제거
* 시스템의 낭비 요소 제거와 품질을 향상시킨 방법론
* JIT, 칸반보드를 사용함
    * `칸반 보드` : 작업을 시각화하고 작업에 탐여한 팀 업무와 팀원의 작업량을 파악하는 애자일 도구

<br>

### [기타 애자일 유형]
Crystal : 프로세스보다 도구보다는 사람이 중요하다는 방법론
* 최대 6명 ~ 8명의 공동 배치 소프트웨어 개발자 팀에 적용  

ASD(Adaptive Software Development) : 개발을 혼란 자체로 규정함
* 합동 애플리케이션 개발 (Joint Application Development) 을 사용

FDD(Feature Driven Deveopment) : 개발을 상품, 서비스 단위가 아닌 기능 단위로 개발

<br>

## 4. Reference
* https://velog.io/@csy9604/1%EA%B3%BC%EB%AA%A9-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%84%A4%EA%B3%84-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD-%ED%99%95%EC%9D%B8-UML
* https://gmlwjd9405.github.io
* https://seb.kr/w/DFD