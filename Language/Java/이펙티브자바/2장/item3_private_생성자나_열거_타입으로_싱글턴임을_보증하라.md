# [item3] private 생성자나 열거 타입으로 싱글턴임을 보증하라

## 싱글턴이란?

싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말한다.

### 싱글턴 패턴의 장점
**메모리 낭비 방지**: 무분별한 new 연산을 하지 않으므로 메모리 낭비를 방지할 수 있다.<br/>

**비용 절감**: 인스턴스 생성 비용이 큰 경우, 단 한 번만 생성하여 재사용할 수 있다.<br/>

**데이터 공유**: 전역 접근을 통해 데이터 공유가 가능하다.<br/>

<br/>

### 싱글턴 패턴의 단점
**높은 결합도**: 싱글턴 인스턴스가 너무 많은 책임을 가지게 되면, 이를 사용하는 클래스들 간의 결합도가 높아져 유지보수가 어려워질 수 있다.<br/>

**동시성 문제**: 무상태를 보장해야 하는데, 개발자의 실수로 '상태'를 가지게 되면 동시성 문제가 발생할 수 있다.<br/>

**테스트 어려움**: 싱글턴 클래스를 사용하는 클라이언트를 테스트하기 어려울 수 있다.<br/>
-> 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴이 아니라면, 싱글턴 인스턴스를 가짜(mock) 구현으로 <br/>대체할 수 없기 때문이다.

<br/>

이 책에서는 싱글턴을 만드는 방법 3가지가 소개 된다. 
1. public static final 필드 방식 
2. 정적 팩터리 메서드 방식
3. enum type 방식

위의 방식들 중 3번째 방식은 사용함에 있어 어색하게 느껴질 수가 있고, 실제로 잘 사용하지도 않는 방식이라고 해서 <br/>
이 글에서는 1, 2번째 방법만 다루었다.

<br/>

## 싱글턴을 만드는 방법

### 1. public static final 필드 방식

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();   << 해당 방식
    private Elvis() {
        // private 생성자
    }

    public void leaveTheBuilding() {
        // 메서드 구현
    }
}
```

이 방법에서는 `public static final 필드`인 `INSTANCE`가 클래스 로딩 시 한 번만 초기화된다.<br/>
그리고 클래스 외부에서 접근 가능한 생성자가 없기 때문에 싱글턴을 보장한다.

### 장점
**명확한 접근 방식**: `Elvis.INSTANCE`로 싱글턴 인스턴스에 접근할 수 있어 명확하다. <br/>
**간결한 소스 코드**: 코드가 간결하고 이해하기 쉽다. <br/>

<br/>

### 2. 정적 팩터리 메서드 방식

```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() {
        // private 생성자
    }

    public static Elvis getInstance() {
        return INSTANCE;
    }

    public void leaveTheBuilding() {
        // 메서드 구현
    }
}
```

이 방법에서는 `Elvis.getInstance()` 메서드가 항상 동일한 `Elvis` 인스턴스를 반환하므로, 제2의 `Elvis` 인스턴스가 <br/>
생성되지 않는다.<br/>

### 장점

**유연성**: 클라이언트 코드의 변경 없이 동작 방식을 변경할 수 있습니다. 예를 들어, 싱글턴 구현 방식을 변경하거나<br/> 
서브클래스를 반환하도록 수정할 수 있다.

**제네릭 싱글턴 팩터리**: 정적 팩터리 메서드를 제네릭 싱글턴 팩터리로 만들 수 있다. <br/>

**메서드 참조 사용 가능**: 정적 팩터리 메서드의 메서드 참조를 공급자(Supplier)로 사용할 수 있다.